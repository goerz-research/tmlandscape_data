#!/usr/bin/env python
"""Select best runs from stage 1, create stage 2 runfolders"""
import os
import re
import sys
import logging
from QDYN import shutil
import QDYN
from analytical_pulses import AnalyticalPulse

def trunc_cat(c):
    """Truncate the given category

    >>> print trunc_cat('1freq_center')
    1freq
    """
    return c[:c.index('_')]


def select_for_stage3(stage2_table, target='PE'):
    """For each choice of (w2, wc, category), keep only the row that best
    fulfills the target (PE or SQ)

    stage2_table must contain the columns 'w_2 [GHz]', 'w_c [GHz]', 'category',
    'J_PE', and 'J_SQ', and use the stage2 runfolder as an index
    """
    table = stage2_table.copy()
    table['category'] = table['category'].apply(trunc_cat)

    return table\
        .groupby(['w2 [GHz]', 'wc [GHz]', 'category'], as_index=False)\
        .apply(lambda df: df[df.index==df['J_%s'%target].idxmin()])\
        .reset_index(level=0,drop=True)


def all_select_runs(runs, dry_run=False):
    """Analyze the runfolders generated by run_state1.py, select the best runs
    in preparation for stage 2"""
    from notebook_utils import get_stage2_table
    from os.path import join, isfile
    logger = logging.getLogger(__name__)
    stage2_table = get_stage2_table(runs)
    n_runfolders = 0
    for target in ['PE', 'SQ']:
        table = select_for_stage3(stage2_table,  target)
        for stage2_runfolder, row in table.iterrows():
            pulse_json = os.path.join(stage2_runfolder, 'pulse_opt.json')
            if not os.path.isfile(pulse_json):
                continue
            guess_pulse = AnalyticalPulse.read(pulse_json).pulse()
            rwa = ('rwa' in AnalyticalPulse.read(pulse_json).formula_name)
            stage3_runfolder = os.path.join(runs,
                              'w2_%dMHz_wc_%dMHz' % (row['w2 [GHz]']*1000,
                                                     row['wc [GHz]']*1000),
                              'stage3',
                              '%s_%s' % (target, row['category']))
            n_runfolders += 1
            guess_pulse_file = join(stage3_runfolder, 'pulse.guess')
            if isfile(guess_pulse_file):
                existing_guess = QDYN.pulse.Pulse(guess_pulse_file)
                if guess_pulse.preamble != existing_guess.preamble:
                    logger.warn("%s does not correspond to %s",
                                guess_pulse_file, pulse_json)
            else:
                if dry_run:
                    print "Expand %s -> %s; write config" % (
                            pulse_json, guess_pulse_file)
                else:
                    shutil.mkdir(stage3_runfolder)
                    guess_pulse.write(guess_pulse_file)
                    config_in  = os.path.join(stage2_runfolder, 'config')
                    config_out = os.path.join(stage3_runfolder, 'config')
                    write_config(config_in, config_out, guess_pulse, target,
                                 rwa)
    print "Total number of runfolders: %d" % n_runfolders


def write_config(config_in, config_out, pulse, target, rwa=False):
    """Write the config file 'config_out' based on the information in
    'config_in' and the given (guess) pulse"""
    with open(config_in) as in_fh, open(config_out, 'w') as out_fh:
        skip = False
        T = pulse.T
        time_unit = pulse.time_unit
        nt = len(pulse.tgrid) + 1
        is_complex = 'F'
        if rwa:
            is_complex = 'T'
        for line in in_fh:
            if line.strip() == "":
                # end of section ends skipping
                skip = False
            elif line.strip().startswith('tgrid'):
                skip = True
                out_fh.write("tgrid: n = 1\n")
                out_fh.write("1 : t_start = 0.0, t_stop = %g_%s, nt = %d"
                             % (T, time_unit, nt))
            elif line.strip().startswith('pulse'):
                skip = True
                out_fh.write(
"""
pulse: n = 1
1: type = file, filename = pulse.guess, id = 1,  time_unit = {time_unit}, &
   ampl_unit = MHz, is_complex = {is_complex}, oct_increase_factor = 5.0, &
   oct_outfile = pulse.dat, oct_lambda_a = 1.0e-1, oct_lambda_intens = 0.0, &
   oct_shape = flattop, shape_t_start = 0.0, t_rise = {t_rise}_{time_unit}, &
   shape_t_stop = {T}_{time_unit}, t_fall = {t_rise}_{time_unit}, check_tgrid = F

oct: iter_stop = 100, max_megs = 9000, type = krotov2, &
     A = 0, B = 0, C = 0.0, iter_dat = oct_iters.dat, &
     keep_pulses = prev, max_hours = 10,  continue = T, dynamic_sigma = T, &
     sigma_form = local, J_T_conv = 0, lbfgs_memory = 10
""".format(T=T, t_rise=min(0.1*T, 10), is_complex=is_complex,
           time_unit=time_unit))
            elif line.strip().startswith('user_strings'):
                if target == 'PE':
                    out_fh.write("user_strings: gate = sqrt_iSWAP, J_T = PE\n")
                elif target == 'SQ':
                    out_fh.write("user_strings: gate = unity, J_T = LI\n")
                else:
                    raise ValueError("target must be 'PE' or 'SQ': %s"
                                     % target)
                line = ''
            elif line.strip().startswith('oct'):
                skip = True
            elif line.strip().startswith('user_reals'):
                out_fh.write(line)
                out_fh.write("LI_unitarity_weight = 0.01, &\n")
                line = ''
            elif line.strip().startswith('LI_unitarity_weight'):
                line = ''
            if 'prop_guess' in line:
                line = re.sub(r'prop_guess\s*=\s*T', 'prop_guess = F', line)
            if not skip:
                out_fh.write(line)


def main(argv=None):
    """Main routine"""
    from optparse import OptionParser
    if argv is None:
        argv = sys.argv
    arg_parser = OptionParser(
    usage = "usage: %prog [options] RUNS",
    description = __doc__)
    arg_parser.add_option(
        '-n', action='store_true', dest='dry_run',
        default=False, help="Perform dry-run")
    options, args = arg_parser.parse_args(argv)
    try:
        runs = os.path.join('.', os.path.normpath(args[1]))
    except IndexError:
        arg_parser.error("You must give RUNS")
    if not os.path.isdir(runs):
        arg_parser.error("RUNS must be a folder (%s)" % runs)
    if not runs.startswith(r'./'):
        arg_parser.error('RUNS must be relative to current folder, '
                         'e.g. ./runs')
    all_select_runs(runs, dry_run=options.dry_run)


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    sys.exit(main())
